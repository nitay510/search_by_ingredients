#!/usr/bin/env python
"""
   Add vegan / keto flags to a cleaned ingredient list via GPT-3.5

   $ python tag_ingredients.py --src clean_ingredients.csv \
                                --out ingredients_labeled.csv \
                                --batch-size 50 --debug
"""
from __future__ import annotations
import argparse, csv, json, os, sys, time
from pathlib import Path

import backoff       # pip install backoff
import openai        # pip install openai
import pandas as pd

MODEL = "gpt-3.5-turbo"
SYSTEM_MSG = (
    "You are a food‚Äêlabeling assistant.\n"
    "For every item you receive:\n"
    "  ‚Ä¢ If it's a valid ingredient word/phrase, keep it as-is.\n"
    "  ‚Ä¢ Otherwise, replace it with the closest real ingredient word.\n"
    "Return JSON with keys: ingredient (string), isVegan (true/false), isKeto (true/false).\n"
    "Assume keto = ‚â§ 4 g net carbs per 100 g and vegan = contains no animal products.\n"
)

# --------------------------------------------------------------------- #
def gpt_prompt(batch: list[str]) -> str:
    bullet_list = "\n".join(f"- {x}" for x in batch)
    return (
        f"Label every line below.\n"
        f"Respond ONLY with a JSON array, one object per line *in the same order*.\n\n"
        f"{bullet_list}"
    )

@backoff.on_exception(backoff.expo, openai.error.RateLimitError, max_time=60)
def call_gpt(batch: list[str]) -> list[dict]:
    """Ask GPT and return a list of dicts matching the batch length."""
    resp = openai.ChatCompletion.create(
        model=MODEL,
        messages=[
            {"role": "system", "content": SYSTEM_MSG},
            {"role": "user",   "content": gpt_prompt(batch)},
        ],
        temperature=0,
    )
    txt = resp.choices[0].message.content.strip()
    try:
        data = json.loads(txt)
    except json.JSONDecodeError as e:
        raise RuntimeError(f"‚ö†Ô∏è  GPT did not return valid JSON:\n{txt}") from e
    if not isinstance(data, list) or len(data) != len(batch):
        raise ValueError("GPT response length mismatch.")
    return data

# --------------------------------------------------------------------- #
def tag_ingredients(src: Path, out: Path, batch_size: int, debug: bool):
    df  = pd.read_csv(src)
    raw = df["ingredient"].tolist()

    records: list[dict] = []
    for i in range(0, len(raw), batch_size):
        chunk = raw[i : i + batch_size]
        data  = call_gpt(chunk)
        records.extend(data)

        if debug:
            ok   = sum(r["isVegan"] for r in data)        # type: ignore
            keto = sum(r["isKeto"]  for r in data)        # type: ignore
            print(f"üîç GPT batch {i//batch_size+1:>3}: "
                  f"{len(chunk)} items  |  vegan ‚úì {ok}/{len(chunk)}  "
                  f"keto ‚úì {keto}/{len(chunk)}", file=sys.stderr)

    # final CSV ‚Äî keep ONLY the three requested columns
    with out.open("w", newline="", encoding="utf-8") as fh:
        w = csv.writer(fh)
        w.writerow(["ingredient", "isVegan", "isKeto"])
        for r in records:
            w.writerow([r["ingredient"], bool(r["isVegan"]), bool(r["isKeto"])])

    print(f"\n‚úÖ  {len(records):,} rows written ‚Üí {out}")

# --------------------------------------------------------------------- #
if __name__ == "__main__":
    ap = argparse.ArgumentParser(description="Label ingredients as vegan / keto via GPT-3.5")
    ap.add_argument("--src",        default="clean_ingredients.csv", type=Path,
                    help="CSV generated by clean_ingredients.py")
    ap.add_argument("--out",        default="ingredients_labeled.csv", type=Path)
    ap.add_argument("--batch-size", default=25, type=int,
                    help="how many ingredients to send per GPT request (default 25)")
    ap.add_argument("--debug",      action="store_true",
                    help="print one-line status after every GPT call")
    args = ap.parse_args()

    if "OPENAI_API_KEY" not in os.environ:
        sys.exit("‚ùå  Please set your OPENAI_API_KEY environment variable first.")

    tag_ingredients(args.src, args.out, args.batch_size, args.debug)
